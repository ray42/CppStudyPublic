#include <iostream>
#include <string>
#include <vector>
#include <cctype> // std::isspace
#include <algorithm> // std::max


#include "ray_string.h"
// p131 ch5.6: Taking string apart.


using std::cout; using std::endl; using std::cin;
using std::string; 
using std::vector;
using std::isspace;
using std::max; using std::find_if;

// true if the argument is whitespace, false otherwise
bool space(char c)
{
  return isspace(c);
}

// false is the argument is whitespace, true otherwise
bool not_space(char c)
{
  return !isspace(c);
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//vector<string> split(const string& str)
//{
//  typedef string::const_iterator iter;
//  vector<string> ret;
//
//  iter i = str.begin();
//
//  while(i != str.end())
//  {
//    // ignore leading blanks
//    i = find_if(i,str.end(),not_space);
//
//    // find end of next word
//    iter j = find_if(i,str.end(),space);
//
//    // copy the characters in [i,j)
//    if(i != str.end())
//      ret.push_back(string(i,j));
//
//    i = j;
//  }
//  return ret;
//}


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

string::size_type width(const vector<string>& v)
{
  string::size_type maxlen = 0;
  for(vector<string>::size_type i = 0;
      i != v.size(); ++i)
  {
    maxlen = max(maxlen,v[i].size());
  }
  return maxlen;
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


vector<string> frame(const vector<string>& v)
{
  vector<string> ret;
  string::size_type maxlen = width(v);
  string border(maxlen+4,'*');

  // write the top boarder
  ret.push_back(border);

  // write each interior row, bordered by an asterisk and a space
  for (vector<string>::size_type i = 0; 
       i != v.size(); ++i) 
  {
    ret.push_back("*" + v[i] +
        string(maxlen - v[i].size(),' ')+ " *");
  }

  // write the bottom border
  ret.push_back(border);
  return ret;
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

vector<string> vcat(const vector<string>& top, const vector<string>& bottom)
{
  // copy the top picture
  vector<string> ret = top;

//  // copy entire bottom picture
//  for(vector<string>::const_iterator it=bottom.begin();
//      it != bottom.end(); ++it)
//    ret.push_back(*it);
  ret.insert(ret.end(),bottom.begin(),bottom.end());
  return ret;
}


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

vector<string>
hcat(const vector<string>&left, const vector<string>& right)
{
  vector<string> ret;
  
  // add 1 to leave a space between pictures
  string::size_type width1 = width(left)+1;

  // indices to look at elements from left and right respectively
  vector<string>::size_type i = 0, j=0;

  // continue until we've seen all rows from both pictures
  while(i != left.size() || j != right.size())
  {
    // construct new string to hold characters from both pictures
    string s;

    // copy a row from the left-hand side, if there is one
    if(i != left.size())
    {
      s=left[i++];
    }

    // pad to full width
    s += string(width1 - s.size(), ' ');

    // copy a row from the right-hand side, if there is one
    if(j != right.size())
    {
      s+=right[j++];
    }

    // add s to the picture we're creating.
    ret.push_back(s);
  }
  return ret;
}



////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////






